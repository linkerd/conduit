syntax = "proto3";

package conduit.proxy.accept_policy;

import "common/common.proto";

service AcceptPolicy {
  // Describes how a proxy should accept inbound connections from remote peers.
  //
  // Includes;
  // - Protocol detection
  // - [TODO] TLS termination
  rpc Inbound(InboundAcceptPolicyRequest) returns (stream InboundAcceptPolicy) {}

  // Describes how a proxy should accept outbound connections from local peers.
  //
  // Includes;
  // - Protocol detection
  rpc Outbound(OutboundAcceptPolicyRequest) returns (stream OutboundAcceptPolicy) {}
}

message InstanceId {
  // TODO
}

message InboundAcceptPolicyRequest {
  InstanceId instance_id = 1;
}

// Describes how an inbound proxy should accept connections and requests to be routed.
//
// Inbound proxies may terminate TLS as they accept a connection.
message InboundAcceptPolicy {
  repeated EndpointMatch detection_disabled = 1;
}

message OutboundAcceptPolicyRequest {
  InstanceId instance_id = 1;
}

// Describes how an outbound proxy should accept connections and requests to be routed.//
//
// Outbound pdroxies do not terminate TLS as they accept a connection--TLSed streams are
// handled as opaque TCP.
message OutboundAcceptPolicy {
  repeated EndpointMatch detection_disabled = 1;
}


// Matches a set of endpoints considered to be "opaque" TCP endpoints on which protocol
// detection should be bypassed.
message EndpointMatch {
  Net net = 1;
  repeated uint32 ports = 2;

  message Net {
    common.IPAddress ip = 1;
    uint32 mask = 2;
  }
}
